### Объектно-ориентированное программирование (ООП / Аврора), 2 семестр, РТУ МИРЭА

Здесь хранятся код, программы для авроры (практики, курсовые) и разбор вопросов билета (экзамена)


### Списки вопросов экзамена
1. Аргументы, передаваемые функции по умолчанию.
2. Архитектура системы. Иерархия объектов.
3. Ввод-вывод в С++. Потоки.
4. В чем различие между ссылкой и указателем?
5. Виртуальные базовые классы.
6. Взаимодействие объектов. Три примера взаимодействия объектов.
7. Виртуальные методы. Наследование виртуальных методов.
8. В чем отличие между классом и структурой?
9. Встраиваемая функция.
10. Для чего используется ключевое слово protected?
11. Дружественная функция.
12. Дружественный класс.
13. Защищенные члены класса.
14. Жизненный цикл объекта.
15. Жизненный цикл виртуального объекта и его реализация на языке С++.
16. Инкапсуляция.
17. Имеются два способа сделать функцию встраиваемой. Что это за
способы?
18. Исключительные ситуации.
19. Класс. Назначение и синтаксис описания.
20. Класс vector.
21. Класс string.
22. Какая инструкция catch перехватывает все типы исключительных
ситуаций?
23. Какова основная форма конструктора копий?
24. Конструктор копии.
25. Контейнеры и итераторы.
26. Контейнер – динамический массив.
27. Какое условие является обязательным для присвоения одного объекта
другому?
28. Контейнер – ассоциативный список.
29. Какой тип операций ведет к вызову конструктора копий?
30. Конструктор и деструктор объекта.
31. Класс map и multimap.
32. Можно ли адрес объекта передать функции в качестве аргумента?
33. Множественное наследование.
34. Можно ли использовать инструкцию throw, если ход выполнения
программы не затрагивает инструкции, расположенные в блоке try?
35. Может ли быть инициализирован массив, память для которого
выделяется динамически?
36. Наследование. Реализация наследования на языке С++.
37. Объявление элементов класса спецификацией static.
38. Объявление элементов класса спецификацией const.
39. Объявление объекта и доступ к его элементам.
40. Объединение. Назначение и синтаксис описания.
41. Объекты в качестве возвращаемого значения функции.
42. Определение адреса перегруженной функции.
43. Определение системы и три примера систем.
44. Перегрузка бинарных операторов.
45. При наследовании одного класса другим, когда вызываются
конструкторы классов? Когда вызываются их деструкторы?
46. Полиморфизм.
47. Параметризированные конструкторы.
48. Программа – система.
50. Перегрузка оператора индексации массивов [ ]
51. Присвоение объектов.
52. Приведение типов.
53. Перегрузка функций.
54. Перегрузка унарных операторов.
55. Структура. Назначение и синтаксис описания.
56. Операторы new и delete.
57. Сигналы и обработчики.
58. Форматированный ввод-вывод данных.
59. Что такое родовой класс и какова его основная форма?
60. Что происходит, когда открытые члены базового класса наследуются как
открытые? Что происходит, когда они наследуются как закрытые?
61. Чисто виртуальные функции и абстрактные классы.
62. Что такое родовая функция и какова ее основная форма?
63. Что такое встраиваемая функция? В чем ее преимущества и недостатки?
64. Чем действие дружественной оператор-функции отличается от действия
оператор-функции — члена класса?
65. Что такое объект?
66. Что происходит с защищенным членом класса, когда класс наследуется
как открытый? Что происходит, когда он наследуется как закрытый?
67. Управление доступом к элементам класса.
68. Указатели и ссылки на объект.
69. Указатель на объект производного класса
70. Управление доступом при наследовании.
71. Указатель this.
72. Шаблон класса.
73. Шаблон функции.
