### Огромное спасибо
- https://github.com/vyragosa/OOP-exam-questions
- https://github.com/po4yka/university-notes/blob/master/2%20course/%D0%9E%D0%9E%D0%9F/theory.md
- https://drive.google.com/file/d/1vVSHTY6vrBenuqdAqJpRjcaCi7CkPXAS/view
- https://github.com/fadyat/ITMO-PROBLEMS/blob/master/OOP/III%20semester/Test/tickets-OOP.md

<details><summary><h3> Списки вопросов экзамена</h3></summary>

1. Аргументы, передаваемые функции по умолчанию.
2. Архитектура системы. Иерархия объектов.
3. Ввод-вывод в С++. Потоки.
4. В чем различие между ссылкой и указателем?
5. Виртуальные базовые классы.
6. Взаимодействие объектов. Три примера взаимодействия объектов.
7. Виртуальные методы. Наследование виртуальных методов.
8. В чем отличие между классом и структурой?
9. Встраиваемая функция.
10. Для чего используется ключевое слово protected?
11. Дружественная функция.
12. Дружественный класс.
13. Защищенные члены класса.
14. Жизненный цикл объекта.
15. Жизненный цикл виртуального объекта и его реализация на языке С++.
16. Инкапсуляция.
17. Имеются два способа сделать функцию встраиваемой. Что это за
способы?
18. Исключительные ситуации.
19. Класс. Назначение и синтаксис описания.
20. Класс vector.
21. Класс string.
22. Какая инструкция catch перехватывает все типы исключительных
ситуаций?
23. Какова основная форма конструктора копий?
24. Конструктор копии.
25. Контейнеры и итераторы.
26. Контейнер – динамический массив.
27. Какое условие является обязательным для присвоения одного объекта
другому?
28. Контейнер – ассоциативный список.
29. Какой тип операций ведет к вызову конструктора копий?
30. Конструктор и деструктор объекта.
31. Класс map и multimap.
32. Можно ли адрес объекта передать функции в качестве аргумента?
33. Множественное наследование.
34. Можно ли использовать инструкцию throw, если ход выполнения
программы не затрагивает инструкции, расположенные в блоке try?
35. Может ли быть инициализирован массив, память для которого
выделяется динамически?
36. Наследование. Реализация наследования на языке С++.
37. Объявление элементов класса спецификацией static.
38. Объявление элементов класса спецификацией const.
39. Объявление объекта и доступ к его элементам.
40. Объединение. Назначение и синтаксис описания.
41. Объекты в качестве возвращаемого значения функции.
42. Определение адреса перегруженной функции.
43. Определение системы и три примера систем.
44. Перегрузка бинарных операторов.
45. При наследовании одного класса другим, когда вызываются
конструкторы классов? Когда вызываются их деструкторы?
46. Полиморфизм.
47. Параметризированные конструкторы.
48. Программа – система.
50. Перегрузка оператора индексации массивов [ ]
51. Присвоение объектов.
52. Приведение типов.
53. Перегрузка функций.
54. Перегрузка унарных операторов.
55. Структура. Назначение и синтаксис описания.
56. Операторы new и delete.
57. Сигналы и обработчики.
58. Форматированный ввод-вывод данных.
59. Что такое родовой класс и какова его основная форма?
60. Что происходит, когда открытые члены базового класса наследуются как
открытые? Что происходит, когда они наследуются как закрытые?
61. Чисто виртуальные функции и абстрактные классы.
62. Что такое родовая функция и какова ее основная форма?
63. Что такое встраиваемая функция? В чем ее преимущества и недостатки?
64. Чем действие дружественной оператор-функции отличается от действия
оператор-функции — члена класса?
65. Что такое объект?
66. Что происходит с защищенным членом класса, когда класс наследуется
как открытый? Что происходит, когда он наследуется как закрытый?
67. Управление доступом к элементам класса.
68. Указатели и ссылки на объект.
69. Указатель на объект производного класса
70. Управление доступом при наследовании.
71. Указатель this.
72. Шаблон класса.
73. Шаблон функции.

</details>

# Теория
## 1. Аргументы, передаваемые функции по умолчанию
Иногда в функцию нужно указать аргументы (параметры), которые могут принимать дефолтные значения (например 0). В данном случае их можно не указывать при вызове функции. Аргументы по умолчанию объявляются в прототипе функции. Как правило при объявлении классов, эти аргументы объявляются в конструкторе (а если быть точнее в прототипе/заголовке, не в теле/реализации). 

Особенности аргументов по умолчанию:
- Можно не указывать при вызове функции, потому что они добавляются компилятором автоматически (пример, b = 0)
- Объявляются в прототипе функции, причем **ПОСЛЕДНИМИ**, то есть **ПОСЛЕ** тех аргументов у которых нет значений по умолчанию (иначе возникнет ошибка компиляции)
- Чтобы использовать аргументы по умолчанию, эта функция должна быть соответствующим образом объявлена

Преимущества аргументов по умолчанию:
- сокращается листинг программного кода за счет избежания лишних функций, которые выполняют ту же работу только с другими значениями аргументов
- обеспечивается простой, естественный и эффективный стиль программирования;
- аргументы = сокращенной формой "перегрузки" функции. Улучшает читабельность кода и упрощает вызов функции.

Во время объявления функции, аргументы по умолчанию задаются только 1 раз. Здесь возможны 2 случая:
1. Случай, если функция имеет прототип и реализацию.
2. Случай, если функция не имеет прототипа, а имеет только реализацию.

## 2. Архитектура системы. Иерархия объектов.
**Архитектура** – это набор значимых решений по поводу организации **системы** программного обеспечения, набор структурных элементов и их интерфейсов, при помощи которых компонуется **система**

**Архитектура системы** так или иначе строится путем создания **иерархии** объектов и взаимодействия между объектами.

**Объектная декомпозиция** - разбиение системы на объекты. Такая декомпозиция существенно упрощает конструирование сложных систем. Разработка интерфейсов взаимодействия происходит между объектами системы и внешней средой. Способ организации интерфейса зависит от особенности объекта и его назначения. Схематически это представлено на следующем:

![системка](https://github.com/mireashik/oop_2sem/assets/123753819/3688e049-3a0a-4a80-905c-69344bd54508)

## 3. Ввод-вывод в С++. Потоки.
В С++ нет встроенных средств ввода-вывода, поэтому поточный ввод-вывод выполняется с помощью функций сторонних библиотек (**stdio.h** и **iostream**)

Библиотекой **iostream** определено 2 типа:
- istream (поток ввода)
- ostream (поток вывода)

**Поток** - последовательность символов, которая записывается на устройство ввода или считывается с него (например консоль). 
<br>
Для **записи / вывода** символов на консоль - объект `cout`, для **чтения** - объект `cin`. Есть еще `cerr` - объект потока вывода сообщений об **ошибках**

Для выполнения операций ввода-вывода переопределены две операции поразрядного сдвига:
<br>
`>>` - получить из входного потока
<br>
`<<` - поместить в выходной поток

Ввод информации: из входного потока читается последовательность символов до пробела, затем эта последовательность преобразуется к типу идентификатора, и получаемое значение помещается в **идентификатор**

**Вывод информации: определяется тип данных переменной**, подлежащей выводу, и выбирается соответствующий оператор вставки потока для отображения значения. Оператор << перегружен для вывода элементов данных встроенных типов и значений указателя

Работа с файлами: функционал для работы с ними предоставляет заголовочный файл fstream.
<br>
Там определены 2 класса:
- ifstream
- ofstream

Реализующие возможности чтения и записи информации

## 4. В чем различие между ссылкой и указателем?
Указатель – переменная, значением которой является адрес ячейки памяти.
<br>
Ссылки – переменная, с особым типом данных, являющийся скрытой формой указателя, значение которой автоматически разыменовывается.

Различия:
- Указатель хранит адрес объекта, ссылка ссылается на него напрямую (скрыто хранит указатель)
- Ссылка, в отличии от указателя, не может быть неинициализированной (она обязательно указывает на какой-то объект)
- Ссылка не может быть изменена после инициализации
- У ссылки нет адреса (это просто другое имя для того же объекта)
- Существует арифметика указателей, но нет арифметики ссылок
- Инициализировать неконстантную ссылку константным объектом нельзя
- Нельзя напрямую изменить значение по константной ссылке, тем не менее мы можем изменить сам объект

```c++
int a; // переменная по адресу 0xdd000075
int &ra = a; // ссылка, которая ссылается на переменную а (по факту просто другое имя переменной, их значения одинаковые)

cout << &a; // 0xdd000075
cout << &ra; // 0xdd000075
```

```c++
int a = 3;
int b = 5;
int &ra = a; // ссылка, которая ссылается на переменную а (по факту просто другое имя переменной, их значения одинаковые
int *p = &a; // указатель содержащий ардес переменной a
p = &b; // указатель получает адрес переменной b
    
cout << *p; // 5
cout << endl;
cout << ra; // 3
```

### **Арифметика указателей**
Адрес указателя можно увеличить и уменьшать на значение равное размеру типа указателя (количеству байтов)

- double = 8
- int = 4
- short = 2
- char = 1

После изменения адреса мы можем получить значение, которое находится по новому адресу, однако это значение может быть неопределенным

Чтобы использовать свойства и методы **объекта** через указатель, необходимо использовать `->` вместо `.`

## 5. Виртуальные базовые классы
> **Note**: Как известно, в С++ ключевое слово virtual используется для объявления виртуальных функций, которые будут переопределены в производных классах (**ПРО ЭТО В БИЛЕТЕ 7 и 61!!!**)

**Виртуальный базовый класс** - решение так называемой проблемы ромба, когда существует 2 копии базового класса - по одной для каждого наследника.
<br>
Иногда желательно, чтобы частью обоих классов наследников была 1 базового класса

Ромбовидное наследование — вид множественного наследования, когда 2 класса B и C наследуют от A, а класс D наследует от обоих классов B и C. При этой схеме может возникнуть неоднозначность: если объект класса D вызывает метод, определенный в классе A (и этот метод не был переопределен в классе D), а классы B и C **по-своему** переопределили этот метод, то от какого класса его наследовать: B или C? 

![изображение](https://github.com/mireashik/oop_2sem/assets/123753819/f93b5579-0ac3-4f77-add9-0647baf4529e)

При использовании `virtual` существует только 1 базовый объект. Этот базовый объект используется всеми объектами в дереве наследования и создается только 1 раз.

Встретив ключевое слово virtual, компилятор помечает, что для этого метода должно использоваться позднее связывание: для начала он создает для класса таблицу виртуальных функций, а в класс добавляет новый скрытый для программиста член — указатель на эту таблицу

```c++
// Пример ошибки ромба
class BaseClass {
    public:
    int num;
};

class ParentClass1: public BaseClass{};

class ParentClass2: public BaseClass{};

class ChildClass: public ParentClass1, public ParentClass2 {};

int main() {
   ChildClass obj;
   obj.num = 1; // Ошибка! неявное имя переменной
   return 0;
}
```

### Есть 2 способа решения проблемы
```c++
// Оператор разрешения области видимости :: позволяет явно выбрать вариант производного класса.
// Однако данный способ решения порождает проблемы: Что если нужна лишь 1 копия объекта, дублирование недопустимо
obj.ParentClass1::num = 1;
```

```c++
class BaseClass {
    public:
    int num;
};
// Как видим, перед именем базового класса в спецификации производного класса стоит ключевое слово virtual
class ParentClass1: virtual public BaseClass {};

class ParentClass2: virtual public BaseClass {};

// Теперь оба класса являются наследниками виртуального класса BaseClass, и любые их наследники будут содержать лишь 1 копию базового класса
// Следовательно, выражение obj.num = 1 становится однозначным
class ChildClass: public ParentClass1, public  ParentClass2 {};

int main() {
   ChildClass obj;
   obj.num = 1;
   return 0;
}
```

## 6. Взаимодействие объектов. Три примера взаимодействия объектов.
Возможны следующие отношения объектов:

- **Наследование** (класс наследник имеет **все** поля и методы родительского класса и, как правило, добавляет новый функционал и поля). Наследование описывается словом “является”
- **Композиция** - включаемый объект создается в конструкторе класса-владельца (двигатель создается при создании автомобиля и полностью им управляется, объект A управляет **временем жизни** объекта B)
- **Агрегация** - включаемый объект создается где-то еще и потом передается в качестве параметра в конструктор класса-владельца (объект А **получает ссылку** на объект B)

Композиция и агрегация - частный случаи **ассоциации**, то есть включения одного класса в другой в качестве одного из полей. Ассоциация описывается словом “имеет”

### Примеры:
Если отвертка цельная, ручка и насадка намертво связаны - композиция
<br>
Если же насадка съемная (может существовать без ручки или же использоваться с другой ручкой) - агрегация

Композиция: `университет — факультеты`, факультеты без университета погибают. 
<br>
Агрегация: `профессора — факультеты`, профессора остаются жить после разрушения факультета

![изображение](https://github.com/mireashik/oop_2sem/assets/123753819/3fe84460-a846-4dcd-bdba-2e7b98a31dfe)

## 7. Виртуальные методы. Наследование виртуальных методов.
**Виртуальная функция** — функция-член, **объявленная** в базовом классе и **переопределенная** в производном (принадлежит самому дочернему классу из имеющихся функций в базовом и производном классах)

То есть эта функция которая просто существует в базовом классе (определяет способ работы), но её реализация определяет каждый отдельный дочерний класса (пример полиморфизма - возможность одного и того же кода работать с РАЗНЫМИ типами данных)

Программисту необязательно знать тип объекта для работы через виртуальные методы: достаточно лишь, что объект принадлежит классу или наследнику класса, в котором объявлен метод.

Если функция помечена как виртуальная, все совпадающие переопределения также считаются виртуальными, даже если они явно не отмечены как таковые.

Виртуальные функции **не должны** вызываться из конструкторов или деструкторов потому что часть производного класса к этому моменту еще не будет создана или будет уничтожена.

Виртуальные функции являются иерархическими.

Виртуальную функцию **не обязательно** определять в классе наследнике. В этом случае вызывается функция, определенная в базовом классе.

```c++
class Base {
    public:
    virtual void f();
};
class Derived: public Base {
public:
    void f();
};

pb -> f();
```

### 8. В чем отличие между классом и структурой?
**Структуры** (struct) - служат для хранения каких-то общедоступных данных в виде публичных переменных. Для остальных сценариев используются классы (class).

- Члены класса, определенного с помощью ключевого слова **class** - по умолчанию являются **private**
- Члены класса, определенного с помощью ключевого слова **struct** / **union** - по умолчанию являются **public**

Инициализация структур аналогична инициализации массивов:

```c++
person tom { 34, "Tom" };
```

Иногда подобные сущности еще называют **аггрегатными классами** (aggregate classes).

### 9. Встраиваемая функция.
**Inline функции** - при вызове заменяются компилятором фактическим кодом из функции (вместо самого вызова функции). Основная идея в том, чтобы ускорить программу ценой занимаемого места.

При определении и использовании встраиваемых функций необходимо придерживаться следующих правил:
- Определение и объявление функций должны быть совмещены и располагаться перед первым вызовом встраиваемой функции.
- Имеет смысл определять `inline` только очень небольшие функции, поскольку любая inline-функция увеличивает программный код.
- Различные компиляторы накладывают ограничения на сложность встраиваемых функций. Компилятор сам решает, может ли функция быть встраиваемой. Если функция не может быть `inline`, компилятор рассматривает её как обычную функцию.

Встроенные функции очень хороши для ускорения программы, но если вы используете их слишком часто или с большими функциями, у вас будет чрезвычайно большая программа.
<br>
Иногда большие программы менее эффективны, и поэтому они будут работать медленнее, чем раньше.
<br>
Встроенные функции лучше всего подходят для небольших функций, которые часто вызываются.

> **Note**: Смотрите также эту тему в БИЛЕТЕ 17!

## 10. Для чего используется ключевое слово protected?
**Protected** — определяет элемент как ограниченный для доступа. Обратиться к данной переменной или метода можно только в рамках **текущего класса, классах наследниках и дружественной функции**

Также protected используется как - **тип наследования**. При private наследовании public и protected -> private

> **Note**: Про типы наследования смотрите БИЛЕТ 59, 60, 66 и 70!

## 11. Дружественная функция.
**Дружественные функции** - это функции, которые **НЕ** являются членами класса, однако **ИМЕЮТ** доступ к его **private** членам. Для определения дружественных функций используется ключевое слово `friend`.

Дружественные функции **не являются членами класса и не наследуются**.

Методы класса используются для реализации свойств объекта. В виде дружественных функции оформляются действия, не представляющие свойства класса, но концептуально входящие в состав класса и нуждающиеся в  доступе к его скрытым полям, например:

- Перегрузка операторов
- Вспомогательное назначение - переопределение операции вывода объекта в поток вывода.

В качестве параметра ей должен передаваться **объект, ссылка или указатель на объект**, так как указатель **this не доступен**. Дружественная функция может быть внешней функцией или **методом другого** класса. Определение дружественной функции осуществляется **вне класса**, действие спецификатора доступа на нее не распространяется.

## 12. Дружественный класс.
Класс можно объявить **дружественным** по отношению к другому классу при ключевого слова `friend`. В таком случае в ЭТОМ классе можно будет получить доступ к private и protected свойствам и методам ДРУГОГО класса.

## 13. Защищенные члены класса.
Если необходимо защитить член класса от доступа извне, но позволить использовать его **производным** классам, используется другое ключевое слово  — `protected` (защищенный).

Если продолжить аналогию, это напоминает семейную ценность, передаваемую по наследству.

Таким образом, указав специфи­катор доступа protected, можно позволить использовать атрибуты и методы внутри иерархии и запретить доступ к нему извне этой иерархии.

> **Note**: Подробнее указано в БИЛЕТЕ 10, а также перекликается с таблицей в БИЛЕТЕ 70!

## 14. Жизненный цикл объекта.
1. План (описание) - любой объект должен до его появления быть описан (до появления объекта требуется его описание). План - описание объекта, также содержащий четкие требования относительно ресурсов для создания обьекта
2. Создание (конструирование) - на базе плана. В плане прописаны требования ресурсов, не только описание объекта.
3. Старт объекта - появление объекта (старт объекта в физическом, материализованном смысле).
4. Функционирование - начало работы объекта
5. Остановка - окончание ресурса объекта
6. Демонтаж
7. Уничтожение

## 15. Жизненный цикл виртуального объекта и его реализация на языке С++.
Язык обеспечивает жизненный цикл виртуального объекта **по аналогии** жизненного цикла объекта из предметной области. Схемы этих жизненных циклов совпадают.

1. Описание - Class
2. Создание - Отработка constructor объекта, выделение памяти
3. Старт объекта - Завершение работы constructor, начало функционирования
4. Функционирование - Участие объекта в работе программы
5. Остановка - Вызов destructor
6. Демонтаж - Отработка constructor
7. Завершение - Завершение работы destructor, освобождение памяти

## 16. Инкапсуляция
Все программы состоят из 2 основных элементов: инструкций (кода) и данных. Инкапсуляцию разделяет логики и поведения.
<br>
Логика — то, как что-то устроено внутри.
<br>
Поведение — то, как оно взаимодействует с другими сущностями.
<br>
Разделение этих двух понятий упрощает взаимодействие объектов в коде.

**Код** – это часть программы, которая выполняет действия, а данные представляют собой информацию, на которую направлены эти действия.
<br>
**Инкапсуляция** - это такой механизм программирования, который связывает воедино код и данные (объединение всех свойств объекта), которые он обрабатывает и что его определяет, чтобы обезопасить их как от внешнего вмешательства, так и от неправильного использования.

Суть инкапсуляции - доступ к данным разрешен только методам класса, напрямую обратиться к их содержимому нельзя. Например, поместить радиоактивные отходы в капсулу, закрыть кожухом механизм, убрать мешающее в ящик или шкаф

На базе 1 класса могут быть созданы множество объектов. Объект созданный согласно описанию класса поддерживает инкапсуляцию. У каждого объекта есть свои границы («рамки»). Эта граница определяется согласно описанию пространства класса. Внутри объекта - код / данные или обе эти составляющие, могут быть закрытыми в «рамках» этого объекта или открытыми.

**Закрытый код (или данные)** известен и доступен только другим частям того же объекта. **Вне** этого объекта **доступ не имеет**.
<br>
**Открытый код (или данные)** доступны **любым** другим частям программы, даже если они определены в других объектах. Обычно открытые части объекта используются для предоставления управляемого интерфейса с закрытыми элементам объекта.

## 17. Имеются два способа сделать функцию встраиваемой. Что это за способы?
1. Способ определение кода реализации в заголовочной части класса `define`
2. Способ относится к части реализации `inline`

Синтаксис представления:

```c++
inline «тип метода» «имя класса» :: «имя метода» ( [«параметры»] ) { // код реализации }
```

В базовом языке С директива препроцессора `#define` позволяет использовать макроопределения для записи вызова небольших часто используемых конструкций (различных констант и выражений). Некорректная запись макроопределения может приводить к ошибкам, которые очень трудно найти. Макроопределения не позволяют определять локальные переменные и не выполняют проверки и преобразования аргументов.

Таким образом, использование ключевого слова `inline` для встраиваемых функций и ключевого слова `const` для определения констант позволяют практически исключить директиву препроцессора #define из употребления.

> **Note**: Начало этой темы БИЛЕТЕ 9!

## 18. Исключительные ситуации
**Исключительная ситуация** - событие при выполнении программы, которое приводит к ее ненормальному или неправильному поведению.

Выделяют 2 вида исключительных ситуаций:
- **Аппаратные** - которые генерируются процессором:
- - Деление на 0
- - Выход за границы массива
- - Обращение к невыделенной памяти
- - Переполнение разрядной сетки
- **Программные** - генерируемые операционной системой и прикладными программами. Когда встречается аномальная ситуация, та часть программы, которая ее обнаружила, может сгенерировать, или возбудить, исключение (вызываются самим программистом с помощью `throw`)

Идея **обработки исключительных ситуаций** состоит в том, что функция, обнаружившая проблему, но не знающая как её решить, генерирует исключение в надежде, что вызвавшая её функция сможет решить возникшую проблему. Функция, которая может решать проблемы данного типа, указывает, что она перехватывает такие исключения.

Для реализации обработки исключений в C++ используйте выражения **try, throw и catch**:
<br>
Блок `try {...}` позволяет включить 1 или несколько операторов, которые могут создавать исключение.
<br>
Выражение `throw` - используется только для программных исключений, т.е. исключительное условие произошло в блоке `try`.
<br>
Для обработки исключений - 1 или несколько блоков `catch` сразу после блока `try`. Каждый блок `catch` указывает тип исключения, которое он может обрабатывать.

![19](https://github.com/mireashik/oop_2sem/assets/123753819/6600ea6e-2131-4711-9f3b-e9714611d8e9)
![20](https://github.com/mireashik/oop_2sem/assets/123753819/422299b0-15e0-461b-ba8a-a0f2d337f94f)
![21](https://github.com/mireashik/oop_2sem/assets/123753819/59c0d306-8687-4ba3-b671-96149a05f45e)
![22](https://github.com/mireashik/oop_2sem/assets/123753819/5ae10d17-31d7-439c-b27c-73a4c4e32c8c)
![23](https://github.com/mireashik/oop_2sem/assets/123753819/dfe59b37-df1c-43f6-adb8-0d46ee36f34a)
![24](https://github.com/mireashik/oop_2sem/assets/123753819/c063f5e5-f6df-4251-885f-e4659fc0403a)
![25](https://github.com/mireashik/oop_2sem/assets/123753819/55d55aae-94d9-427c-9b2b-5679c5f4552e)
![26](https://github.com/mireashik/oop_2sem/assets/123753819/6da85700-bde0-45d0-9ab4-0ab50563671b)
![27](https://github.com/mireashik/oop_2sem/assets/123753819/9fc23cfb-0ab7-43c2-be24-6e2d18fba19f)
![28](https://github.com/mireashik/oop_2sem/assets/123753819/41537064-bd1d-4f3f-9c25-48114e428b25)
![29](https://github.com/mireashik/oop_2sem/assets/123753819/c3c9096e-c29f-43c9-b66f-793f8b16fc5d)
![30](https://github.com/mireashik/oop_2sem/assets/123753819/0828b98d-bf50-49c8-a8b9-442ee8394aa5)
![30](https://github.com/mireashik/oop_2sem/assets/123753819/daccc7f2-6c7a-4238-8768-45f70a279c76)
![31](https://github.com/mireashik/oop_2sem/assets/123753819/af7eeb2a-659d-497f-88fc-0abc175cfd79)
![32](https://github.com/mireashik/oop_2sem/assets/123753819/92f6f779-4f42-4b56-8d37-e1f03a860576)
![33](https://github.com/mireashik/oop_2sem/assets/123753819/77bc5c62-77ca-45d5-9af9-8903875840e7)
![34](https://github.com/mireashik/oop_2sem/assets/123753819/8fdea623-267f-495a-92ad-03fd53a7bfc5)
![35](https://github.com/mireashik/oop_2sem/assets/123753819/99ad79bd-efba-4782-a5cf-77b74926f6d3)
![36](https://github.com/mireashik/oop_2sem/assets/123753819/3bf0f5aa-74da-49c6-a723-b822006bb1fa)
![37](https://github.com/mireashik/oop_2sem/assets/123753819/48962adb-e662-4a80-a285-7715b35dd487)
![38](https://github.com/mireashik/oop_2sem/assets/123753819/a8664076-185c-4236-8e6c-2e5092410f57)
![39](https://github.com/mireashik/oop_2sem/assets/123753819/5983300b-d41b-4595-b1ae-316f9f82cfa2)
![40](https://github.com/mireashik/oop_2sem/assets/123753819/0a9c2d4d-794a-4922-9e79-a48b76d58986)
![41](https://github.com/mireashik/oop_2sem/assets/123753819/fcbb1ca0-7b35-4ced-98a1-dce8631b7c5d)
![42](https://github.com/mireashik/oop_2sem/assets/123753819/df0b0b78-5b21-4aaa-a308-31ddac82d9b0)
![43](https://github.com/mireashik/oop_2sem/assets/123753819/3327a53d-3a4c-4e77-ad0a-d1c3dcde557f)
![44](https://github.com/mireashik/oop_2sem/assets/123753819/b00ad65d-b8b0-4d41-97ae-1c3f1438dd42)
![45](https://github.com/mireashik/oop_2sem/assets/123753819/62fad288-dc6d-4d30-99af-f16001253489)
![46](https://github.com/mireashik/oop_2sem/assets/123753819/3d574b01-dbfa-4086-97ae-810d022b9d47)
![47](https://github.com/mireashik/oop_2sem/assets/123753819/28b8e675-a10e-4f62-b477-d40620e63321)
![48](https://github.com/mireashik/oop_2sem/assets/123753819/b239e44a-5587-4439-8cd6-f1b7d089d79a)
![48](https://github.com/mireashik/oop_2sem/assets/123753819/83bff844-c1ce-48df-acbc-de5718725051)
![50](https://github.com/mireashik/oop_2sem/assets/123753819/1bb3f34d-e128-4074-8a29-fd23eb9e9b8f)
![51](https://github.com/mireashik/oop_2sem/assets/123753819/05780803-b9ef-40e3-8896-ad636e96944c)
![52](https://github.com/mireashik/oop_2sem/assets/123753819/355c36fb-62d8-410d-a636-5552649a7e0d)
![53](https://github.com/mireashik/oop_2sem/assets/123753819/0989ac4d-fc4d-4851-bead-ab765cd95869)
![54](https://github.com/mireashik/oop_2sem/assets/123753819/d6cab7e9-1971-4014-8714-7c0221b62bf3)
![55](https://github.com/mireashik/oop_2sem/assets/123753819/278805a8-7152-4a76-a71b-985ad4e628fb)
![56](https://github.com/mireashik/oop_2sem/assets/123753819/ef552601-8139-417f-8725-38c8ecee0c39)
![57](https://github.com/mireashik/oop_2sem/assets/123753819/50c3320a-981e-472c-8a03-1777bf870e3c)
![58](https://github.com/mireashik/oop_2sem/assets/123753819/30abd802-d631-4d30-bd78-9c5a92c86d50)
![59](https://github.com/mireashik/oop_2sem/assets/123753819/e6755aef-2b64-4b0b-8b28-71c8a9fe1cdd)
![60](https://github.com/mireashik/oop_2sem/assets/123753819/9dac7cf8-c4f3-4eb6-9b9d-c5ad86ccc59a)
![61](https://github.com/mireashik/oop_2sem/assets/123753819/dd81d8b3-2d5e-437b-b366-be811db72e3f)
![62](https://github.com/mireashik/oop_2sem/assets/123753819/ce182119-db4e-4b64-aced-25b92404f220)
![63](https://github.com/mireashik/oop_2sem/assets/123753819/030332c6-79e5-4ffd-8cba-3cccdb54e267)
![64](https://github.com/mireashik/oop_2sem/assets/123753819/8fa46cc8-2514-4978-a7a0-bb5e34607b46)
![65](https://github.com/mireashik/oop_2sem/assets/123753819/ef5aec72-7709-47c2-b990-1e8dfc9fd7ae)
![67](https://github.com/mireashik/oop_2sem/assets/123753819/113708e1-17b8-4ff6-af08-3ffdc9601301)
![68](https://github.com/mireashik/oop_2sem/assets/123753819/2660afea-a6d7-4538-8555-974957ece4da)
![69](https://github.com/mireashik/oop_2sem/assets/123753819/e451d7aa-0115-4406-91f4-709dc6dbc233)
![71](https://github.com/mireashik/oop_2sem/assets/123753819/67495f1f-6921-47db-995a-72f08c4bd23f)
![72](https://github.com/mireashik/oop_2sem/assets/123753819/bcfd6276-bb80-4280-a39f-c41972117a92)
![73](https://github.com/mireashik/oop_2sem/assets/123753819/3ca57a03-4966-44a9-a357-d6a45e213fb3)

# Практика
![74](https://github.com/mireashik/oop_2sem/assets/123753819/a05d6403-bdc7-4fd8-ba09-d187f8388604)
![75](https://github.com/mireashik/oop_2sem/assets/123753819/7dcc2a2e-b434-475c-ab19-a3677f3065a3)
![76](https://github.com/mireashik/oop_2sem/assets/123753819/eac7faed-5cfc-419b-8213-07489bb2e54b)
![77](https://github.com/mireashik/oop_2sem/assets/123753819/c1fe4210-feda-4dd1-baa3-71928339c0d4)
![78](https://github.com/mireashik/oop_2sem/assets/123753819/088b0569-8ae0-440e-901b-307aa808dbf9)
![79](https://github.com/mireashik/oop_2sem/assets/123753819/39aa5a88-64b6-40b7-8b5d-c3def5a6fe9f)
![80](https://github.com/mireashik/oop_2sem/assets/123753819/9e9ca898-7078-4687-a444-03dce05196c9)
![81](https://github.com/mireashik/oop_2sem/assets/123753819/d33417a4-82af-41c1-914a-0cafac6f0275)
![82](https://github.com/mireashik/oop_2sem/assets/123753819/fcb4435a-8041-4179-ae28-27ab6afd50ec)
![83](https://github.com/mireashik/oop_2sem/assets/123753819/d8d5c29f-71df-4af5-b01f-2d0550830bd4)
![84](https://github.com/mireashik/oop_2sem/assets/123753819/86d57fdb-d63c-4277-b207-99d2b5ccf6f7)
![85](https://github.com/mireashik/oop_2sem/assets/123753819/706e82ed-0eeb-4c24-831a-5f808305f997)
![86](https://github.com/mireashik/oop_2sem/assets/123753819/e229a184-7732-43b1-babe-b5c017bd5195)
![87](https://github.com/mireashik/oop_2sem/assets/123753819/b14fab75-f3bf-4828-84ea-cc83e92949e9)
![88](https://github.com/mireashik/oop_2sem/assets/123753819/fde6fb23-d962-4a71-ac10-4b1679b23140)
![89](https://github.com/mireashik/oop_2sem/assets/123753819/6e7b6b40-c685-4219-921b-c7c782ca1137)
![90](https://github.com/mireashik/oop_2sem/assets/123753819/c30f8605-4ce2-4a0b-914a-52aa4a2c121f)
![91](https://github.com/mireashik/oop_2sem/assets/123753819/cf2b2dec-0a31-44dc-b0e7-7a43d65c1a6a)
![92](https://github.com/mireashik/oop_2sem/assets/123753819/fe74e4c0-57b4-4fba-8a5d-596243682f0c)
![93](https://github.com/mireashik/oop_2sem/assets/123753819/6c8847dc-30be-4c11-bd89-e7e84a6812e3)
![94](https://github.com/mireashik/oop_2sem/assets/123753819/d273575d-3059-4b93-baae-2804f532d0ee)
![95](https://github.com/mireashik/oop_2sem/assets/123753819/39aad470-1c73-44c4-8ccd-9aff47178b62)
![96](https://github.com/mireashik/oop_2sem/assets/123753819/668ff827-b26c-468d-b581-e0bf40074846)
![97](https://github.com/mireashik/oop_2sem/assets/123753819/0f309455-97e6-477b-9591-13955697ed44)
![98](https://github.com/mireashik/oop_2sem/assets/123753819/59cb2ff4-0db2-463a-ba9c-f3f38de5a647)
![99](https://github.com/mireashik/oop_2sem/assets/123753819/2bc44d81-965c-45b7-9881-e2157b01a6ea)
![100](https://github.com/mireashik/oop_2sem/assets/123753819/6e58ecf6-c3a0-47fd-a9fa-a7103aaad978)
![101](https://github.com/mireashik/oop_2sem/assets/123753819/494534ab-4e06-40fc-b8c0-691c757fc321)
![102](https://github.com/mireashik/oop_2sem/assets/123753819/86446318-eb35-47e1-831c-0e6154115ee5)
![103](https://github.com/mireashik/oop_2sem/assets/123753819/0b8361d3-d05f-44af-b88c-56401f5086c8)



